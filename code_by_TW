#include <Servo.h>
Servo servo;

/**
 * Black IR detection: 33
 * White IR detection: 21
 */

const int SERVO1_PIN = 9; // 서보모터1 연결핀
const int IR_R = A3;      //  적외선센서 우측 핀
const int IR_L = A4;      // 적외선센서 좌측 핀

const int M1_PWM = 5;  // DC모터1 PWM 핀 왼
const int M1_DIR1 = 7; // DC모터1 DIR1 핀
const int M1_DIR2 = 8; // DC모터 1 DIR2 핀

const int M2_PWM = 6;   // DC모터2 PWM 핀
const int M2_DIR1 = 11; // DC모터2 DIR1 핀
const int M2_DIR2 = 12; // DC모터2 DIR2 핀

const int FC_TRIG = 13; // 전방 초음파 센서 TRIG 핀
const int FC_ECHO = 10; // 전방 초음파 센서 ECHO 핀
const int L_TRIG = A2;  // 좌측 초음파 센서 TRIG 핀
const int L_ECHO = A1;  // 좌측 초음파 센서 ECHO 핀
const int R_TRIG = 2;   // 우측 초음파 센서 TRIG 핀
const int R_ECHO = A5;  // 우측 초음파 센서 ECHO 핀

const int MAX_DISTANCE = 2000; // 초음파 센서의 최대 감지거리

const int PAUSE_TIME = 2000;

float center;
float left;
float right;

int state = 0;
int count_lines = 0;

// 자동차 튜닝 파라미터 =====================================================================
int detect_ir = 26; // 검출선이 흰색과 검정색 비교

int punch_pwm = 200; // 정지 마찰력 극복 출력 (0 ~ 255)
int punch_time = 50; // 정지 마찰력 극복 시간 (단위 msec)
int stop_time = 300; // 전진후진 전환 시간 (단위 msec)

int max_ai_pwm = 130; // 자율주행 모터 최대 출력 (0 ~ 255)
int min_ai_pwm = 70;  // 자율주행 모터 최소 출력 (0 ~ 255)

int angle_offset = -6; // 서보 모터 중앙각 오프셋 (단위: 도)
int angle_limit = 55;  // 서보 모터 회전 제한 각 (단위: 도)

int center_detect = 200; // 전방 감지 거리 (단위: mm)
int center_start = 160;  // 전방 출발 거리 (단위: mm)
int center_stop = 70;    // 전방 멈춤 거리 (단위: mm)

int side_detect = 100; // 좌우 감지 거리 (단위: mm)

float cur_steering;
float cur_speed;
float compute_steering;
float compute_speed;

float max_pwm;
float min_pwm;

int start = 0;

// 초음파 거리측정
float GetDistance(int trig, int echo)
{
    digitalWrite(trig, LOW);
    delayMicroseconds(4);
    digitalWrite(trig, HIGH);
    delayMicroseconds(20);
    digitalWrite(trig, LOW);

    unsigned long duration = pulseIn(echo, HIGH, 5000);
    if (duration == 0)
        return MAX_DISTANCE;
    else
        return duration * 0.17; // 음속 340m/s
}

int ir_sensing(int pin)
{
    return analogRead(pin);
}

// 앞바퀴 조향
void SetSteering(float steering)
{
    cur_steering = constrain(steering, -1, 1); // constrain -1~ 1 값으로 제한

    float angle = cur_steering * angle_limit;
    int servoAngle = angle + 90;
    servoAngle += angle_offset;

    servoAngle = constrain(servoAngle, 0, 180);
    servo.write(servoAngle);
}

// 뒷바퀴 모터회전
void SetSpeed(float speed)
{
    speed = constrain(speed, -1, 1);

    if ((cur_speed * speed < 0)            // 움직이는 중 반대 방향 명령이거나
        || (cur_speed != 0 && speed == 0)) // 움직이다가 정지라면
    {
        cur_speed = 0;
        digitalWrite(M1_PWM, HIGH);
        digitalWrite(M1_DIR1, LOW);
        digitalWrite(M1_DIR2, LOW);

        digitalWrite(M2_PWM, HIGH);
        digitalWrite(M2_DIR1, LOW);
        digitalWrite(M2_DIR2, LOW);

        if (stop_time > 0)
            delay(stop_time);
    }

    if (cur_speed == 0 && speed != 0) // 정지상태에서 출발이라면
    {
        if (punch_time > 0)
        {
            if (speed > 0)
            {
                analogWrite(M1_PWM, punch_pwm);
                digitalWrite(M1_DIR1, HIGH);
                digitalWrite(M1_DIR2, LOW);

                analogWrite(M2_PWM, punch_pwm);
                digitalWrite(M2_DIR1, HIGH);
                digitalWrite(M2_DIR2, LOW);
            }
            else if (speed < 0)
            {
                analogWrite(M1_PWM, punch_pwm);
                digitalWrite(M1_DIR1, LOW);
                digitalWrite(M1_DIR2, HIGH);

                analogWrite(M2_PWM, punch_pwm);
                digitalWrite(M2_DIR1, LOW);
                digitalWrite(M2_DIR2, HIGH);
            }
            delay(punch_time);
        }
    }

    if (speed != 0) // 명령이 정지가 아니라면
    {
        int pwm = abs(speed) * (max_pwm - min_pwm) + min_pwm; // 0 ~ 255로 변환

        if (speed > 0)
        {
            analogWrite(M1_PWM, pwm);
            digitalWrite(M1_DIR1, HIGH);
            digitalWrite(M1_DIR2, LOW);

            analogWrite(M2_PWM, pwm);
            digitalWrite(M2_DIR1, HIGH);
            digitalWrite(M2_DIR2, LOW);
        }
        else if (speed < 0)
        {
            analogWrite(M1_PWM, pwm);
            digitalWrite(M1_DIR1, LOW);
            digitalWrite(M1_DIR2, HIGH);

            analogWrite(M2_PWM, pwm);
            digitalWrite(M2_DIR1, LOW);
            digitalWrite(M2_DIR2, HIGH);
        }
    }
    cur_speed = speed;
}

void DifRotation(float speed, float steering) {
  // speed 에 양수가 오면 전진 else 후진
  // steering 에 양수 오면 우회전 아니면 좌회전 (전진 기준)

    // 전축 회전
    cur_steering = constrain(steering, -1, 1); // constrain -1~ 1 값으로 제한

    float angle = cur_steering * angle_limit;
    int servoAngle = angle + 90;
    servoAngle += angle_offset;

    servoAngle = constrain(servoAngle, 0, 180);
    servo.write(servoAngle);

    int pwm = abs(speed) * 225;  // 0 ~ 255

    if (speed > 0) {
      analogWrite(M1_PWM, pwm);
      digitalWrite(M1_DIR1, HIGH);
      digitalWrite(M1_DIR2, LOW);

      analogWrite(M2_PWM, pwm);
      digitalWrite(M2_DIR1, LOW);
      digitalWrite(M2_DIR2, HIGH);
    }
    else if (speed < 0) {
      analogWrite(M1_PWM, pwm);
      digitalWrite(M1_DIR1, LOW);
      digitalWrite(M1_DIR2, HIGH);

      analogWrite(M2_PWM, pwm);
      digitalWrite(M2_DIR1, HIGH);
      digitalWrite(M2_DIR2, LOW);
    }
  
}

/*void driving()
{
        //시작 정차
    while(start == 0) {
        if (GetDistance(FC_TRIG, FC_ECHO) > center_detect) {
            start ++;
            break;
        }
    }
    compute_steering = cur_steering;
    compute_speed = cur_speed;

    center = GetDistance(FC_TRIG, FC_ECHO);
    left = GetDistance(L_TRIG, L_ECHO);
    right = GetDistance(R_TRIG, R_ECHO);

    if (ir_sensing(IR_R) <= detect_ir && ir_sensing(IR_L) <= detect_ir) // 양쪽 차선이 검출된 경우=>정지선 또는 차선과 정지선을 모두 걸친 경우0
    {
        SetSpeed(0);//일단 정지
        delay(1000);//1초 정지
        SetSpeed(0.05);
        delay(300);//느린 속도로 조금 움직여서 상황 판단
        if(ir_sensing(IR_R)  || ir_sensing(IR_L) <= ???)//한쪽 센서에서 경기장 밖 바닥이 검출되면 정지선과 차선이 걸쳐있던 이상한 상황임을 인지
        {
          if(ir_sensing(IR_R)<= ???)//왼쪽에서 경기장 밖을 검출하면 왼쪽으로 꺾은 후 뒤로 후진, 다시 바퀴가 앞을 향하도록
          {
            servo.write(0);
            SetSpeed(-0.1);
            delay(400);
            SetSpeed(0);
            servo.write(90);
          }
          else if()//오른쪽에서 경기장 밖을 검출하면 오른쪽으로 꺾은 후 뒤로 후진, 다시 바퀴가 앞을 향하도록
          {
            servo.write(180);
            SetSpeed(-0.1);
            delay(400);
            SetSpeed(0);
            servo.write(90);
          
          }
        }
        
        else//정지선이었구나
        { 
         SetSpeed(0.1)//앞으로 조금 더 나가서 무슨 상황인지 확인 
         delay(500)
         if(center==MAX_DISTANCE)//전방에 벽이 안 느껴질 때---->교차로 진입이나 평행주차 중 하나구나
         { 
          if(right<MAX_DISTANCE)//오른쪽에서 벽이 감지되면 평행주차, 감지되지 않으면 교차로 진입(직진)
            ParallelParking();
          else
            straight();
         }
         else if(center<100)//전방에 벽이 느껴질 때
         { 
          if(right<MAX_DISTANCE)//T자인 경우=> 오른쪽 벽이 느껴진다
            RearParking();
          else  //회피주행인 경우=> 오른쪽 벽이 안 느껴진다
            avoid_collision();
         }   
        }
    }
    straight();    
}
*/
void straight() //양쪽 차선이 검출된 경우
{    
    if (ir_sensing(IR_R) >= detect_ir && ir_sensing(IR_L) >= detect_ir) //차선이 검출되지 않을 경우 직진
    {
        compute_steering = 0;
        compute_speed = 1;
    }

    else if (ir_sensing(IR_R) <= detect_ir) // 오른쪽 차선이 검출된 경우
    {
        compute_steering = -1;
        compute_speed = 0.1;
    }

    else if (ir_sensing(IR_L) <= detect_ir) // 왼쪽 차선이 검출된 경우
    {
        compute_steering = 1;
        compute_speed = 0.1;
    }
}

void ParallelParking() {
    //전진하다가 오른쪽 벽이 갑자기 가까워짐을 인식하면 멈추기
    if(right<50)//전진을 덜해서 아직 주차공간에 다다르지 못한 경우
    {
      SetSpeed(0.5);
      delay(500);
    }
    
    while(1) {
      SetSteering(0);
      SetSpeed(0.5);
      delay(25);
      if (right < 150) {
        SetSpeed(0);
        break; //이제 주차 시작할 위치에 도착
      }
    }
    //주차하려는데 차가 한쪽 벽으로 너무 쏠려있을 때
/*    if(|Left-Right|>){
      
    }
*/

    //park - turn right 45deg
    DifRotation(-1, 0.8); //핸들 꺾어서 후진으로 진입
    delay(1000);

    DifRotation(0, 0); //잠깐 정지
    delay(300);
    
    DifRotation(1, 0); //핸들 가운데에 놓고 뒤로 조금 후진
    delay(500);
    
    DifRotation(0, -0.8); //잠깐 정지해서 핸들 왼쪽으로 꺾기
    delay(300);

    SetSpeed(-1); //핸들 꺾인 상태로 마저 후진
    delay(1000);
    
    SetSpeed(0);
    delay(3000); //3초 정지, 주차 완료


    SetSpeed(1); //핸들 여전히 왼쪽으로 꺾인 상태에서 그대로 다시 나오기
    delay(1000);
    DifRotation(0, 0); //잠깐 정지해서 핸들 가운데로
    delay(300);

    SetSpeed(1); // 핸들 가운데에 놓은 상태에서 앞으로 조금 전진
    delay(500);
    DifRotation(1,0.8); //핸들 오른쪽으로 꺾어서 평행주차 끝내기
    delay(1000);
    DifRotation(0,0); //핸들 가운데로 다시 정렬

 
}

void T_Parking(){
    
    //turn left 90deg
    DifRotation(1, -0.8);
    delay(1200);
    DifRotation(0, 0);
    delay(300);
    
    //back till detect
    while(1) {
      SetSpeed(-1);
      if (ir_sensing(IR_R) <= detect_ir && ir_sensing(IR_L) <= detect_ir) {
        SetSpeed(0);
        delay(PAUSE_TIME);
      }
    }
    
    //go forward, to escape detect
    SetSteering(0);
    SetSpeed(1);
    delay(200);
}

void avoid_collision() // TODO Implement avoid collision function
{
    //turn left 90deg
    //just use driving.
    
}

void finish() // TODO Implement finish() functoin
{
    //break loop, to finish program.
    exit(0);
}

void setup()
{

    Serial.begin(115200);
    servo.attach(SERVO1_PIN); // 서보모터 초기화

    pinMode(IR_R, INPUT);
    pinMode(IR_L, INPUT);

    pinMode(M1_PWM, OUTPUT);
    pinMode(M1_DIR1, OUTPUT);
    pinMode(M1_DIR2, OUTPUT);
    pinMode(M2_PWM, OUTPUT);
    pinMode(M2_DIR1, OUTPUT);
    pinMode(M2_DIR2, OUTPUT);

    pinMode(FC_TRIG, OUTPUT);
    pinMode(FC_ECHO, INPUT);

    pinMode(L_TRIG, OUTPUT);
    pinMode(L_ECHO, INPUT);

    pinMode(R_TRIG, OUTPUT);
    pinMode(R_ECHO, INPUT);

    max_pwm = max_ai_pwm;
    min_pwm = min_ai_pwm;

    SetSteering(0);
    SetSpeed(0);
    

            
}

void loop()
{
 ParallelParking();
}
